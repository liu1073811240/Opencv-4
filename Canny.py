import cv2

'''Canny算子：' \
'边缘：一个像素，不一定封闭，是提取轮廓的前提' \
'梯度：不一定是一个像素，有可能是多个像素' \
'轮廓：对于边缘的补充，是封闭的，属于边缘的子集'''
'''
Canny边缘检查算法步骤：
  1.彩色图转化为灰度图
  2.应用高斯滤波来平滑图像-->去除噪声
    由于边缘检测容易受到图像中噪声的影响
  3.找寻图像的强度梯度
    Canny的基本思想是找寻一幅图像中强度变化最强的位置。所谓的变化最强，即指梯度方向。
    平滑后的图像中每个像素点的梯度可以由Sobel算子来获得：
      1）首先，利用Sobel算子得到沿x轴和y轴方向的梯度G_x和G_y。
      2）由G_X和G_Y便可计算每一个像素点的梯度幅值G。
      3）接着，每一个像素点用G代替。对于变化剧烈的边界处，G值越大，对应的颜色为白色。
      4）然后，这些边界通常非常粗，难以标定边界的真正位置，还必须存储梯度的方向θ。
  4.应用非极大抑制技术来消除边误检(本来不是边缘但检测出来是)
    沿着梯度θ方向上比较该像素点，若该像素点与两侧相比最大则保留，否则抑制(置为0)。
    这一步的目的是将模糊的边界变得清晰，剔除一大部分不是边缘的点。
  5.双阈值边缘连接处理
    规则：设定两个阈值，minVal和maxVal。
      大于maxVal的边缘肯定是边缘(保留)，低于minVal的边缘是非边缘(舍去)。
      对于介于两者之间的值，判断是否与真正的边界(强边界)相连，相连就保留，否则丢弃。
  6.二值化图像输出结果
'''

# 1.转化为灰度图
img = cv2.imread("./images/18.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2.高斯模糊
gaussian = cv2.GaussianBlur(gray, (3, 3), 3)

# 3.Canny边缘提取
# canny = cv2.Canny(gray, 50, 150)
canny = cv2.Canny(gaussian, 50, 150)

cv2.imshow("img", img)
cv2.imshow("gaussian", gaussian)
cv2.imshow("canny", canny)
cv2.waitKey(0)
cv2.destroyAllWindows()
